# Java Solutions to Leetcode 

| #        |  Title                                                                                        |  Category                    | Solution          |
|----------|-----------------------------------------------------------------------------------------------|------------------------------|---------------|
| 1        |  [Two Sum](https://leetcode.com/problems/two)                                                 | Hash                         | [solution](java/1_TwoSum)|
| 167      |  [Two Sum II](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)                | Two Pointers / Binary Search | [solution](java/167_TwoSum)| 
| 15       |  [Three Sum](https://leetcode.com/problems/3sum/)                                             | Two Pointers                 | [solution](java/15_ThreeSum)|
| 16       |  [Three Sum Closest](https://leetcode.com/problems/3sum-closest/)                             | Two Pointers                 | [solution](java/16_ThreeSumClosest)|
| 125      |  [Valid Palindrome](https://leetcode.com/problems/valid-palindrome/)                          | Two Pointers                 | [solution](java/125_ValidPalindrome)|
| 680      |  [Valid Palindrome II](https://leetcode.com/problems/valid-palindrome-ii/)                    | Two Pointers                 | [solution](java/680_ValidPalindrome)|
| 611      |  [Valid Triangle Number](https://leetcode.com/problems/valid-triangle-number/)                | Two Pointers                 | [solution](java/611_ValidTriangleNumber)|
| 11       |  [Container With Most Water](https://leetcode.com/problems/container-with-most-water/)        | Two Pointers                 | [solution](java/11_ContainerWithMostWater)|
| 977      |  [Squares Of A Sorted Array](https://leetcode.com/problems/squares-of-a-sorted-array/)        | Two Pointers                 | [solution](java/977_SquaresOfASortedArray)|
| 75       |  [Sort Colors](https://leetcode.com/problems/sort-colors/)                                    | Two Pointers                 | [solution](java/75_SortColors)|
| 121      |  [Best Time To Buy And Sell Stocks](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) | Two Pointers           | [solution](java/121_BestTimeToBuyAndSellStocks)|
| 26       |  [Remove Duplicates From Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)| Two Pointers     | [solution](java/26_RemoveDuplicatesFromSortedArray)|
| 209      |  [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)        | Two Pointers                 | [solution](java/209_MinimumSizeSubarraySum)|
| 713      |  [Subarray Product Less Than K](https://leetcode.com/problems/subarray-product-less-than-k/)  | Two Pointers                 | [solution](java/713_SubarrayProductLessThanK)|
| 992      |  [Subarrays With K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/)| Two Pointers     | [solution](java/992_SubarraysWithKDifferentIntegers)|
| 76       |  [Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)          | Two Pointers                 | [solution](java/76_MinimumWindowSubstring)|
| 283      |  [Move Zeroes](https://leetcode.com/problems/move-zeroes/)                                    | Two Pointers                 | [solution](java/283_MoveZeroes)|
| 781      |  [Rabbits In Forest](https://leetcode.com/problems/rabbits-in-forest/)                        | Two Pointers                 | [solution](java/781_RabbitsInForest)|
| 3        |  [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)| Two Pointers   | [solution](java/3_LongestSubstringWithoutRepeatingCharacters)|
| 424      |  [Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/)| Two Pointers                 | [solution](java/424_LongestRepeatingCharacterReplacement)|
| 1513     |  [Number Of Substrings With Only 1s](https://leetcode.com/problems/number-of-substrings-with-only-1s/)| Two Pointers         | [solution](java/1513_NumberOfSubstringsWithOnly1s)|
| 2161     |  [Partition Array According To Given Pivot](https://leetcode.com/problems/partition-array-according-to-given-pivot/)| Two Pointers  | [solution](java/2161_PartitionArrayAccordingToGivenPivot)|
| 88       |  [Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/)                      | Two Pointers                 | [solution](java/88_MergeSortedArray)|
| 560      |  [Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)                | Two Pointers / Prefix Sum    | [solution](java/560_SubarraySumEqualsK)|
| 704      |  [Binary Search](https://leetcode.com/problems/binary-search/)                                | Binary Search                | [solution](java/704_BinarySearch)|
| 852      |  [Peak Index in Mountain Array](https://leetcode.com/problems/peak-index-in-a-mountain-array/)| Binary Search                | [solution](java/852_PeakIndexInMountainArray)|
| 33       |  [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)| Binary Search              | [solution](java/33_SearchInRotatedSortedArray)|
| 658      |  [Find K Closest Element](https://leetcode.com/problems/find-k-closest-elements/)             | Binary Search                | [solution](java/658_FindKClosestElement)|
| 206      |  [Reverse Linkedlist](https://leetcode.com/problems/reverse-linked-list/)                     | Linked List                  | [solution](java/206_ReverseLinkedlist)|
| 141      |  [Linkedlist Cycle](https://leetcode.com/problems/linked-list-cycle/)                         | Linked List                  | [solution](java/141_LinkedlistCycle)|  
| 234      |  [Palindrome Linkedlist](https://leetcode.com/problems/palindrome-linked-list/)               | Linked List                  | [solution](java/234_PalindromeLinkedlist)| 
| 230      |  [Kth Smallest Element in BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)  | Tree / DFS                   | [solution](java/230_KthSmallestElementInBST)| 
| 104      |  [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)  | Tree / DFS                   | [solution](java/104_MaximumDepthOfBinaryTree)| 
| 110      |  [Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/)                  | Tree / DFS                   | [solution](java/110_BalancedBinaryTree)| 
| 257      |  [Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/)                        | Tree / DFS                   | [solution](java/257_BinaryTreePaths)| 
| 114      |  [Flatten Binary Tree to Linked List](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/)| Tree / DFS         | [solution](java/114_FlattenBinaryTreeToLinkedList)| 
| 236      |  [Lowest Common Ancester of Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)| Tree / DFS | [solution](java/236_LowestCommonAncestorOfBinaryTree)| 
| 102      |  [BinaryTreeLevelOrderTraversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)| Tree / BFS               | [solution](java/102_BinaryTreeLevelOrderTraversal)| 
| 107      |  [BinaryTreeLevelOrderTraversal](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/)| Tree / BFS            | [solution](java/107_BinaryTreeLevelOrderTraversal)| 
| 133      |  [Clone Graph](https://leetcode.com/problems/clone-graph/)                                    | Graph / BFS                  | [solution](java/133_CloneGraph)|
| 127      |  [Word Ladder](https://leetcode.com/problems/word-ladder/)                                    | Graph / BFS                  | [solution](java/127_WordLadder)|
| 200      |  [Number Of Islands](https://leetcode.com/problems/number-of-islands/)                        | Graph / DFS / BFS            | [solution](java/200_NumberOfIslands)|
| 207      |  [Course Schedule](https://leetcode.com/problems/course-schedule/)                            | Graph / DFS / BFS            | [solution](java/207_CourseSchedule)| 
| 17       |  [Letter Combinations Of Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/) | DFS / Combination| [solution](java/17_LetterCombinationsOfPhoneNumber)|
| 39       |  [Combination Sum](https://leetcode.com/problems/combination-sum/)                            | DFS / Combination            | [solution](java/39_CombinationSum)|
| 46       |  [Permutations I](https://leetcode.com/problems/permutations/)                                | DFS / Permutation            | [solution](java/46_Permutations)| 
| 5        |  [Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)| DP                           | [solution](java/5_LongestPalindromeSubstring)| 
| 516      |  [Longest Palindromic Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/)| DP                       | [solution](java/516_LongestPalindromeSubsequence)| 


# Notes in Essential Categories

## Two Pointers（关键词：subarray, substring）
### 1) 相向（two sum型，partition型）
One pointer starting from the beginning of the array, the other pointer starting from the end of the array, and shift towards each other. Incrementing or decrementing the left or right pointers in order to reach a target value. We usually use a while loop with condition left <= right, and the array is usually in some sort of order.

### 2) 同向（sliding window型，fast&slow型）
One pointer starting from the beginning of the array, the other pointer starting from the beginning or the next index right after the first pointer and loop through the rest of the array. We use the second pointer to track the index of some specfiic position. Also occasions when we have two arrays or strings and we use two pointers seperately to loop through.

<img width="551" alt="Screen Shot 2022-07-10 at 1 39 28 PM" src="https://user-images.githubusercontent.com/106039830/178155926-88a1980b-ad9b-4422-a0ae-192911589385.png">


## Binary Search
In a sorted array with boundaries, want to look for a target value or index. </br>

两种写法：</br>
1) 基础写法，用于搜索一个可以通过访问单个索引来确定的元素，无需后续处理直接返回 </br>
while (left <= right) -> left = mid + 1, right = mid - 1; </br>
Eg: 704 </br>
2) 高级写法，用于搜索一个元素时需要访问当前索引元素及其右邻居索引的元素 </br>
while (left < right) -> left = mid + 1, right = mid; </br>
Eg: 33

## Divide and Conquer 
通常应用于二叉树和数组

## Binary Tree / Binary Search Tree / Graph
常见方法：
1) DFS through Recursion </br>
   If have the possibility to visit a node repeatedly, will need to use a hashset to track if the node has already been visited. Eg: in graph </br>
   
   a. Preorder / Inorder / Postorder Traversal 遍历法</br>
   Eg: #230
   
   b. Divide and Conquer 分治法</br>
   需思考整棵树在问题上的结果和根+左子树+右子树的结果的关系：
   左子树返回结果 = DivideAndConquer(root.left) </br>
   右子树返回结果 = DivideAndConquer(root.right) </br>
   整棵树的结果 = 按一定方法合并左右子树结果 </br>
   
   Usually through recursion, but can also use a non recursive / iterative approach through Stack </br>
   1. Create an empty stack S.
   2. Initialize current node as root
   3. Push the current node to S and set current to its left child until current is NULL
   4. If current is NULL and stack is not empty then 
      1) Pop the top item from the stack (LIFO)
      2) Print the popped item, set current to its right child
      3) Go to step 3.
   5. If current is NULL and stack is empty then we are done.
   
2) BFS through Queue </br>
   Queue的实现：Linked List / ArrayDeque (preferred because it is faster) </br>
   
   1. Create an empty queue q
   2. Initialize current node as root
   3. While the queue is not empty
      1) Poll the top item from the queue (FIFO)
      2) Offer its children into the queue in some order
      3) Repeat step 3
    
   If have the possibility to visit a node repeatedly, will need to use a hashset to track if the node has already been visited. </br>
   
   a. Level Order Traversal through Queue </br>
   
      分层 or 不分层？</br>
      分层即在poll前多一层循环
   
      - BFS in Tree: </br>
        Eg: #102 </br>
   
      - BFS in Graph: </br>
        Eg: #133, #127 (shortest path in simple graph)
   
   b. Matrix Traverse（连通块）: </br>
      Eg: #200
   
   c. Topological Sorting（拓扑排序）: </br>
   
      For DAG (directed cyclic graph), for every directed edge uv, vertex u comes before v. </br>
      
      算法描述：</br>
      1) 统计每个点的入度(in degree)
      2) 将每个in degree为0的点放入queue作为起始节点
      3) 不断从queue中拿出一个点，去掉这个点的所有连边
      4) 一旦发现新的in degree为0的点，丢入queue中
      </br>
      
      常见题型：
      
      - 求任意一个拓扑排序 Eg: #207
      - 问是否有拓扑排序
      - 求是否存在且仅存在一个拓扑排序
      - 求字典序最小的拓扑排序
   
Binary Tree 常见题型：
- 二叉树上求值 (Max,Min,Sum,Average,Paths)
- 二叉树结构变化 (Flatten to Linked List)
- BST

## DFS ***(关键词：求全部方案)
Not only in Tree, Graph problems</br>
Can also be used in combination and Permutation problems </br>
Matrix problems, etc

## Dynamic Programming（关键词：最优值，可行性，方案数）

a. 记忆化搜索 Memoization Search through Recursion, 递归方式 </br>
DFS + 记忆 </br>
缺点：不适合O(n)的DP问题，会造成stack overflow

b. 迭代方式 / 多重循环

<img width="798" alt="Screen Shot 2022-06-25 at 9 48 39 PM" src="https://user-images.githubusercontent.com/106039830/175795975-1b332dc0-91ee-47f5-a7f7-ff86e05c4d2e.png">

DP的四要素: 
1) 状态State: 递归的定义 </br>
dp[i][j]定义某个规模更小的问题的答案

2) 方程Function: 递归的拆解
大问题如何拆解为小问题 </br>
dp[i][j]通过规模更小的一些状态求max/min/sum/or来进行推导

3) 初始化Initialize: 递归的出口 </br>
无法再拆解的极限小的状态下的值 </br>
dp[0][0] or dp[i][0] or dp[0][i]

4) 答案Answer: 递归的调用 </br>
最后的return，如dp[m][n]

